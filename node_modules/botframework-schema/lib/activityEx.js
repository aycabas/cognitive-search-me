"use strict";
/**
 * Copyright(c) Microsoft Corporation.All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActivityEx = void 0;
const uuid_1 = require("uuid");
const index_1 = require("./index");
// eslint-disable-next-line @typescript-eslint/no-namespace
var ActivityEx;
(function (ActivityEx) {
    /**
     * Creates an Activity as an IMessageActivity object.
     *
     * @returns The new message activity.
     */
    function createMessageActivity() {
        return { type: index_1.ActivityTypes.Message };
    }
    ActivityEx.createMessageActivity = createMessageActivity;
    /**
     * Creates an Activity as an IContactRelationUpdateActivity object.
     *
     * @returns The new contact relation update activity.
     */
    function createContactRelationUpdateActivity() {
        return { type: index_1.ActivityTypes.ContactRelationUpdate };
    }
    ActivityEx.createContactRelationUpdateActivity = createContactRelationUpdateActivity;
    /**
     * Creates an Activity as an IConversationUpdateActivity object.
     *
     * @returns The new conversation update activity.
     */
    function createConversationUpdateActivity() {
        return { type: index_1.ActivityTypes.ConversationUpdate };
    }
    ActivityEx.createConversationUpdateActivity = createConversationUpdateActivity;
    /**
     * Creates an Activity as an ITypingActivity object.
     *
     * @returns The new typing activity.
     */
    function createTypingActivity() {
        return { type: index_1.ActivityTypes.Typing };
    }
    ActivityEx.createTypingActivity = createTypingActivity;
    /**
     * Creates an Activity as an IHandoffActivity object.
     *
     * @returns The new handoff activity.
     */
    function createHandoffActivity() {
        return { type: index_1.ActivityTypes.Handoff };
    }
    ActivityEx.createHandoffActivity = createHandoffActivity;
    /**
     * Creates an Activity as an IEndOfConversationActivity object.
     *
     * @returns The new end of conversation activity.
     */
    function createEndOfConversationActivity() {
        return { type: index_1.ActivityTypes.EndOfConversation };
    }
    ActivityEx.createEndOfConversationActivity = createEndOfConversationActivity;
    /**
     * Creates an Activity as an IEventActivity object.
     *
     * @returns The new event activity.
     */
    function createEventActivity() {
        return { type: index_1.ActivityTypes.Event };
    }
    ActivityEx.createEventActivity = createEventActivity;
    /**
     * Creates an Activity as an IInvokeActivity object.
     *
     * @returns The new invoke activity.
     */
    function createInvokeActivity() {
        return { type: index_1.ActivityTypes.Invoke };
    }
    ActivityEx.createInvokeActivity = createInvokeActivity;
    /**
     * Creates an Activity as an ITraceActivity object.
     *
     * @param name The name of the trace operation to create.
     * @param valueType Optional, identifier for the format of the @param value . Default is the name of type of the @param value .
     * @param value Optional, the content for this trace operation.
     * @param label Optional, a descriptive label for this trace operation.
     * @returns The new trace activity.
     */
    function createTraceActivity(name, valueType, value, label) {
        return {
            type: index_1.ActivityTypes.Trace,
            name: name,
            label: label,
            valueType: valueType ? valueType : typeof value,
            value: value,
        };
    }
    ActivityEx.createTraceActivity = createTraceActivity;
    /**
     * Creates a new message activity as a response to this activity.
     *
     * @param source The activity to respond.
     * @param text The text of the reply.
     * @param locale The language code for the @param text .
     * @returns The new message activity.
     * @remarks The new activity sets up routing information based on this activity.
     */
    function createReply(source, text, locale) {
        return {
            type: index_1.ActivityTypes.Message,
            timestamp: new Date(),
            from: {
                id: source.recipient ? source.recipient.id : null,
                name: source.recipient ? source.recipient.name : null,
            },
            recipient: {
                id: source.from ? source.from.id : null,
                name: source.from ? source.from.name : null,
            },
            replyToId: getAppropriateReplyToId(source),
            serviceUrl: source.serviceUrl,
            channelId: source.channelId,
            conversation: {
                isGroup: source.conversation.isGroup,
                id: source.conversation.id,
                name: source.conversation.name,
            },
            text: text || '',
            locale: locale || source.locale,
            label: source.label,
            callerId: source.callerId,
            valueType: source.valueType,
            localTimezone: source.localTimezone,
            listenFor: source.listenFor,
            semanticAction: source.semanticAction,
        };
    }
    ActivityEx.createReply = createReply;
    /**
     * Creates a new trace activity based on the source activity.
     *
     * @param source The activity to base the trace.
     * @param name The name of the trace operation to create.
     * @param value Optional, the content for this trace operation.
     * @param valueType Optional, identifier for the format of the @param value . Default is the name of type of the @param value .
     * @param label Optional, a descriptive label for this trace operation.
     * @returns The new trace activity.
     */
    function createTrace(source, name, value, valueType, label) {
        return {
            type: index_1.ActivityTypes.Trace,
            timestamp: new Date(),
            from: {
                id: source.recipient ? source.recipient.id : null,
                name: source.recipient ? source.recipient.name : null,
            },
            recipient: {
                id: source.from ? source.from.id : null,
                name: source.from ? source.from.name : null,
            },
            replyToId: getAppropriateReplyToId(source),
            serviceUrl: source.serviceUrl,
            channelId: source.channelId,
            conversation: source.conversation,
            name: name,
            label: label,
            valueType: valueType ? valueType : typeof value,
            value: value,
        };
    }
    ActivityEx.createTrace = createTrace;
    /**
     * Returns the source activity as an IMessageActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a message activity; or null.
     */
    function asMessageActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Message) ? source : null;
    }
    ActivityEx.asMessageActivity = asMessageActivity;
    /**
     * Returns the source activity as an IContactRelationUpdateActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a contact relation update activity; or null.
     */
    function asContactRelationUpdateActivity(source) {
        return isActivity(source, index_1.ActivityTypes.ContactRelationUpdate) ? source : null;
    }
    ActivityEx.asContactRelationUpdateActivity = asContactRelationUpdateActivity;
    /**
     * Returns the source activity as an IInstallationUpdateActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as an installation update activity; or null.
     */
    function asInstallationUpdateActivity(source) {
        return isActivity(source, index_1.ActivityTypes.InstallationUpdate) ? source : null;
    }
    ActivityEx.asInstallationUpdateActivity = asInstallationUpdateActivity;
    /**
     * Returns the source activity as an IConversationUpdateActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as an conversation update activity; or null.
     */
    function asConversationUpdateActivity(source) {
        return isActivity(source, index_1.ActivityTypes.ConversationUpdate) ? source : null;
    }
    ActivityEx.asConversationUpdateActivity = asConversationUpdateActivity;
    /**
     * Returns the source activity as an ITypingActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a typing activity; or null.
     */
    function asTypingActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Typing) ? source : null;
    }
    ActivityEx.asTypingActivity = asTypingActivity;
    /**
     * Returns the source activity as an IEndOfConversationActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as an end of conversation activity; or null.
     */
    function asEndOfConversationActivity(source) {
        return isActivity(source, index_1.ActivityTypes.EndOfConversation) ? source : null;
    }
    ActivityEx.asEndOfConversationActivity = asEndOfConversationActivity;
    /**
     * Returns the source activity as an IEventActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as an event activity; or null.
     */
    function asEventActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Event) ? source : null;
    }
    ActivityEx.asEventActivity = asEventActivity;
    /**
     * Returns the source activity as an IInvokeActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as an invoke activity; or null.
     */
    function asInvokeActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Invoke) ? source : null;
    }
    ActivityEx.asInvokeActivity = asInvokeActivity;
    /**
     * Returns the source activity as an IMessageUpdateActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a message update request; or null.
     */
    function asMessageUpdateActivity(source) {
        return isActivity(source, index_1.ActivityTypes.MessageUpdate) ? source : null;
    }
    ActivityEx.asMessageUpdateActivity = asMessageUpdateActivity;
    /**
     * Returns the source activity as an IMessageDeleteActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a message delete request; or null.
     */
    function asMessageDeleteActivity(source) {
        return isActivity(source, index_1.ActivityTypes.MessageDelete) ? source : null;
    }
    ActivityEx.asMessageDeleteActivity = asMessageDeleteActivity;
    /**
     * Returns the source activity as an IMessageReactionActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a message reaction activity; or null.
     */
    function asMessageReactionActivity(source) {
        return isActivity(source, index_1.ActivityTypes.MessageReaction) ? source : null;
    }
    ActivityEx.asMessageReactionActivity = asMessageReactionActivity;
    /**
     * Returns the source activity as an ISuggestionActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a suggestion activity; or null.
     */
    function asSuggestionActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Suggestion) ? source : null;
    }
    ActivityEx.asSuggestionActivity = asSuggestionActivity;
    /**
     * Returns the source activity as an ITraceActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a trace activity; or null.
     */
    function asTraceActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Trace) ? source : null;
    }
    ActivityEx.asTraceActivity = asTraceActivity;
    /**
     * Returns the source activity as an IHandoffActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a handoff activity; or null.
     */
    function asHandoffActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Handoff) ? source : null;
    }
    ActivityEx.asHandoffActivity = asHandoffActivity;
    /**
     * Returns the source activity as an ICommandActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a command activity; or null.
     */
    function asCommandActivity(source) {
        return isActivity(source, index_1.ActivityTypes.Command) ? source : null;
    }
    ActivityEx.asCommandActivity = asCommandActivity;
    /**
     * Returns the source activity as an ICommandResultActivity object; or null, if this is not that type of activity.
     *
     * @param source The source activity.
     * @returns This activity as a command result activity; or null.
     */
    function asCommandResultActivity(source) {
        return isActivity(source, index_1.ActivityTypes.CommandResult) ? source : null;
    }
    ActivityEx.asCommandResultActivity = asCommandResultActivity;
    /**
     * Indicates whether the source activity has content.
     *
     * @param source The source activity.
     * @returns True, if this activity has any content to send; otherwise, false.
     * @remarks This method is only intended for use with a message activity, where the Activity Type is set to Message.
     */
    function hasContent(source) {
        if (source.text !== undefined && source.text.trim().length > 0) {
            return true;
        }
        if (source.summary !== undefined && source.summary.trim().length > 0) {
            return true;
        }
        if (source.attachments !== undefined && source.attachments.length > 0) {
            return true;
        }
        if (source.channelData !== undefined) {
            return true;
        }
        return false;
    }
    ActivityEx.hasContent = hasContent;
    /**
     * Resolves the mentions from the entities of the source activity.
     *
     * @param source The source activity.
     * @returns The array of mentions; or an empty array, if none are found.
     * @remarks This method is only intended for use with a message activity, where the Activity Type is set to Message.
     * @see cref="entities" .
     * @see cref="mention" .
     */
    function getMentions(source) {
        return source.entities.filter((x) => x.type.toLowerCase() === 'mention').map((e) => e);
    }
    ActivityEx.getMentions = getMentions;
    /**
     * Creates a ConversationReference based on the source activity.
     *
     * @param source The source activity.
     * @returns A conversation reference for the conversation that contains the activity.
     */
    function getConversationReference(source) {
        return {
            activityId: getAppropriateReplyToId(source),
            bot: source.recipient,
            channelId: source.channelId,
            conversation: source.conversation,
            locale: source.locale,
            serviceUrl: source.serviceUrl,
            user: source.from,
        };
    }
    ActivityEx.getConversationReference = getConversationReference;
    /**
     * Creates an Activity from conversation reference as it is posted to bot.
     *
     * @param reference the conversation reference
     * @returns the activity
     */
    function getContinuationActivity(reference) {
        return {
            type: index_1.ActivityTypes.Event,
            name: index_1.ActivityEventNames.ContinueConversation,
            id: (0, uuid_1.v4)(),
            channelId: reference.channelId,
            locale: reference.locale,
            serviceUrl: reference.serviceUrl,
            conversation: reference.conversation,
            recipient: reference.bot,
            from: reference.user,
            relatesTo: reference,
        };
    }
    ActivityEx.getContinuationActivity = getContinuationActivity;
    /**
     * Determines if the Activity was sent via an Http/Https connection or Streaming.
     * This can be determined by looking at the ServiceUrl property:
     * (1) All channels that send messages via http/https are not streaming
     * (2) Channels that send messages via streaming have a ServiceUrl that does not begin with http/https.
     *
     * @param source The source activity.
     * @returns True if the Activity was originate from a streaming connection.
     */
    function isFromStreamingConnection(source) {
        if (source.serviceUrl !== undefined) {
            const isHttp = source.serviceUrl.toLowerCase().startsWith('http');
            return !isHttp;
        }
        return false;
    }
    ActivityEx.isFromStreamingConnection = isFromStreamingConnection;
    /**
     * Indicates whether this activity is of a specified activity type.
     *
     * @param source The source activity.
     * @param activityType The activity type to check for.
     * @returns True if the activity is of the specified activity type; otherwise, false.
     */
    function isActivity(source, activityType) {
        /*
         * NOTE: This code was migrated from .NET implementation applying optimizations to make
         * it more verbose. The goal is to have zero allocations because it is called by all
         * of the .asXXXActivity methods to "pseudo-cast" the activity based on its type.
         */
        const type = source.type;
        // If there's no type set then we can't tell if it's the type they're looking for
        if (type == undefined || typeof type !== 'string') {
            return false;
        }
        // Check if the full type value starts with the type they're looking for
        let result = type.toUpperCase().startsWith(activityType.toUpperCase());
        // If the full type value starts with the type they're looking for, then we need to check if it's definitely the right type
        if (result) {
            // If the lengths are equal, then it's the exact type they're looking for
            result = type.length === activityType.length;
        }
        if (!result) {
            // Finally, if the type is longer than the type they're looking for then we need to check if there's a / separator right after the type they're looking for
            result = type.length > activityType.length && type[activityType.length] === '/';
        }
        return result;
    }
    ActivityEx.isActivity = isActivity;
})(ActivityEx = exports.ActivityEx || (exports.ActivityEx = {}));
function getAppropriateReplyToId(source) {
    if (source.type !== index_1.ActivityTypes.ConversationUpdate ||
        (source.channelId !== index_1.Channels.Directline && source.channelId !== index_1.Channels.Webchat)) {
        return source.id;
    }
    return undefined;
}
//# sourceMappingURL=activityEx.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotAdapter = void 0;
const internal_1 = require("./internal");
const middlewareSet_1 = require("./middlewareSet");
/**
 * Defines the core behavior of a bot adapter that can connect a bot to a service endpoint.
 *
 * @remarks
 * The bot adapter encapsulates authentication processes and sends activities to and receives
 * activities from the Bot Connector Service. When your bot receives an activity, the adapter
 * creates a turn context object, passes it to your bot application logic, and sends responses
 * back to the user's channel.
 *
 * The adapter processes and directs incoming activities in through the bot middleware pipeline to
 * your bot logic and then back out again. As each activity flows in and out of the bot, each
 * piece of middleware can inspect or act upon the activity, both before and after the bot logic runs.
 * Use the [use](xref:botbuilder-core.BotAdapter.use) method to add [Middleware](xref:botbuilder-core.Middleware)
 * objects to your adapter's middleware collection.
 *
 * For more information, see the articles on
 * [How bots work](https://docs.microsoft.com/azure/bot-service/bot-builder-basics) and
 * [Middleware](https://docs.microsoft.com/azure/bot-service/bot-builder-concept-middleware).
 */
class BotAdapter {
    constructor() {
        this.middleware = new middlewareSet_1.MiddlewareSet();
        this.BotIdentityKey = Symbol('BotIdentity');
        this.ConnectorClientKey = Symbol('ConnectorClient');
        this.OAuthScopeKey = Symbol('OAuthScope');
    }
    /**
     * @internal
     */
    continueConversationAsync(_botAppIdOrClaimsIdentity, _reference, _logicOrAudience, _maybeLogic) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Creates a conversation on the specified channel.
     *
     * @param _botAppId The application ID of the bot.
     * @param _channelId The ID for the channel.
     * @param _serviceUrl The ID for the channel.
     * @param _audience The audience for the connector.
     * <param name="conversationParameters">
     * @param _conversationParameters The conversation information to use to create the conversation
     * @param _logic The method to call for the resulting bot turn.
     * @returns A promise that represents the asynchronous operation
     *
     * @remarks
     * To start a conversation, your bot must know its account information and the user's account information on that
     * channel.  Most _channels only support initiating a direct message (non-group) conversation.
     *
     * The adapter attempts to create a new conversation on the channel, and then sends a `conversationUpdate` activity
     * through its middleware pipeline to the logic method.
     *
     * If the conversation is established with the specified users, the ID of the activity's converstion will contain
     * the ID of the new conversation.
     */
    createConversationAsync(_botAppId, _channelId, _serviceUrl, _audience, _conversationParameters, _logic) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('NotImplemented');
        });
    }
    /**
     * Gets or sets an error handler that can catch exceptions in the middleware or application.
     *
     * @remarks
     * The error handler is called with these parameters:
     *
     * | Name | Type | Description |
     * | :--- | :--- | :--- |
     * | `context` | [TurnContext](xref:botbuilder-core.TurnContext) | The context object for the turn. |
     * | `error` | `Error` | The Node.js error thrown. |
     * @returns {Promise<void>} A promise representing the async operation.
     */
    get onTurnError() {
        return this.turnError;
    }
    /**
     * Sets an error handler that can catch exceptions in the middleware or application.
     *
     * @remarks
     * The error handler is called with these parameters:
     *
     * | Name | Type | Description |
     * | :--- | :--- | :--- |
     * | `context` | [TurnContext](xref:botbuilder-core.TurnContext) | The context object for the turn. |
     * | `error` | `Error` | The Node.js error thrown. |
     */
    set onTurnError(value) {
        this.turnError = value;
    }
    /**
     * Adds middleware to the adapter's pipeline.
     *
     * @param {...any} middlewares The middleware or middleware handlers to add.
     * @returns The updated adapter object.
     * @remarks Middleware is added to the adapter at initialization time.
     * Each turn, the adapter calls its middleware in the order in which you added it.
     */
    use(...middlewares) {
        this.middleware.use(...middlewares);
        return this;
    }
    /**
     * Starts activity processing for the current bot turn.
     *
     * @param context The context object for the turn.
     * @param next A callback method to run at the end of the pipeline.
     * @returns A promise that resolves when the middleware chain is finished
     *
     * @remarks
     * The adapter creates a revokable proxy for the turn context and then calls its middleware in
     * the order in which you added it. If the middleware chain completes without short circuiting,
     * the adapter calls the callback method. If any middleware short circuits, the adapter does not
     * call any of the subsequent middleware or the callback method, and the pipeline short circuits.
     *
     * The adapter calls middleware with a `next` parameter, which represents the next step in the
     * pipeline. Middleware should call the `next` method to continue processing without short circuiting.
     *
     * When the turn is initiated by a user activity (reactive messaging), the callback method will
     * be a reference to the bot's turn handler. When the turn is initiated by a call to
     * [continueConversation](xref:botbuilder-core.BotAdapter.continueConversation) (proactive messaging),
     * the callback method is the callback method that was provided in the call.
     */
    runMiddleware(context, next) {
        return __awaiter(this, void 0, void 0, function* () {
            if (context && context.activity && context.activity.locale) {
                context.locale = context.activity.locale;
            }
            // Wrap context with revocable proxy
            const pContext = (0, internal_1.makeRevocable)(context);
            try {
                yield this.middleware.run(pContext.proxy, () => next(pContext.proxy));
            }
            catch (err) {
                if (this.onTurnError) {
                    yield this.onTurnError(pContext.proxy, err);
                }
                else {
                    throw err;
                }
            }
            finally {
                pContext.revoke();
            }
        });
    }
}
exports.BotAdapter = BotAdapter;
//# sourceMappingURL=botAdapter.js.map
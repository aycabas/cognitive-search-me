"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBotFrameworkAuthenticationFromConfiguration = exports.ConfigurationBotFrameworkAuthentication = void 0;
const z = __importStar(require("zod"));
const botframework_connector_1 = require("botframework-connector");
const configurationServiceClientCredentialFactory_1 = require("./configurationServiceClientCredentialFactory");
const TypedOptions = z
    .object({
    /**
     * (Optional) The OAuth URL used to get a token from OAuthApiClient. The "OAuthUrl" member takes precedence over this value.
     */
    [botframework_connector_1.AuthenticationConstants.OAuthUrlKey]: z.string(),
    /**
     * (Optional) The OpenID metadata document used for authenticating tokens coming from the channel. The "ToBotFromChannelOpenIdMetadataUrl" member takes precedence over this value.
     */
    [botframework_connector_1.AuthenticationConstants.BotOpenIdMetadataKey]: z.string().nullable(),
    /**
     * A string used to indicate if which cloud the bot is operating in (e.g. Public Azure or US Government).
     *
     * @remarks
     * A `null` or `''` value indicates Public Azure, whereas [GovernmentConstants.ChannelService](xref:botframework-connector.GovernmentConstants.ChannelService) indicates the bot is operating in the US Government cloud.
     *
     * Other values result in a custom authentication configuration derived from the values passed in on the [ConfigurationBotFrameworkAuthenticationOptions](xef:botbuilder-core.ConfigurationBotFrameworkAuthenticationOptions) instance.
     */
    [botframework_connector_1.AuthenticationConstants.ChannelService]: z.string(),
    /**
     * Flag indicating whether or not to validate the address.
     */
    ValidateAuthority: z.union([z.string(), z.boolean()]),
    /**
     * The Login URL used to specify the tenant from which the bot should obtain access tokens from.
     */
    ToChannelFromBotLoginUrl: z.string(),
    /**
     * The Oauth scope to request.
     *
     * @remarks
     * This value is used when fetching a token to indicate the ultimate recipient or `audience` of an activity sent using these credentials.
     */
    ToChannelFromBotOAuthScope: z.string(),
    /**
     * The Token issuer for signed requests to the channel.
     */
    ToBotFromChannelTokenIssuer: z.string(),
    /**
     * The OAuth URL used to get a token from OAuthApiClient.
     */
    OAuthUrl: z.string(),
    /**
     * The OpenID metadata document used for authenticating tokens coming from the channel.
     */
    ToBotFromChannelOpenIdMetadataUrl: z.string(),
    /**
     * The The OpenID metadata document used for authenticating tokens coming from the Emulator.
     */
    ToBotFromEmulatorOpenIdMetadataUrl: z.string(),
    /**
     * A value for the CallerId.
     */
    CallerId: z.string(),
    /**
     * Certificate thumbprint to authenticate the appId against AAD.
     */
    [botframework_connector_1.AuthenticationConstants.CertificateThumbprint]: z.string(),
    /**
     * Certificate key to authenticate the appId against AAD.
     */
    [botframework_connector_1.AuthenticationConstants.CertificatePrivateKey]: z.string(),
})
    .partial();
/**
 * Creates a [BotFrameworkAuthentication](xref:botframework-connector.BotFrameworkAuthentication) instance from an object with the authentication values or a [Configuration](xref:botbuilder-dialogs-adaptive-runtime-core.Configuration) instance.
 */
class ConfigurationBotFrameworkAuthentication extends botframework_connector_1.BotFrameworkAuthentication {
    /**
     * Initializes a new instance of the [ConfigurationBotFrameworkAuthentication](xref:botbuilder-core.ConfigurationBotFrameworkAuthentication) class.
     *
     * @param botFrameworkAuthConfig A [ConfigurationBotFrameworkAuthenticationOptions](xref:botbuilder-core.ConfigurationBotFrameworkAuthenticationOptions) object.
     * @param credentialsFactory A [ServiceClientCredentialsFactory](xref:botframework-connector.ServiceClientCredentialsFactory) instance.
     * @param authConfiguration A [Configuration](xref:botframework-connector.AuthenticationConfiguration) object.
     * @param botFrameworkClientFetch A custom Fetch implementation to be used in the [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
     * @param connectorClientOptions A [ConnectorClientOptions](xref:botframework-connector.ConnectorClientOptions) object.
     */
    constructor(botFrameworkAuthConfig = {}, credentialsFactory, authConfiguration, botFrameworkClientFetch, connectorClientOptions = {}) {
        var _a;
        super();
        try {
            const typedBotFrameworkAuthConfig = TypedOptions.nonstrict().parse(botFrameworkAuthConfig);
            const { CallerId, ChannelService, OAuthUrl = typedBotFrameworkAuthConfig[botframework_connector_1.AuthenticationConstants.OAuthUrlKey], ToBotFromChannelOpenIdMetadataUrl = typedBotFrameworkAuthConfig[botframework_connector_1.AuthenticationConstants.BotOpenIdMetadataKey], ToBotFromChannelTokenIssuer, ToBotFromEmulatorOpenIdMetadataUrl, ToChannelFromBotLoginUrl, ToChannelFromBotOAuthScope, } = typedBotFrameworkAuthConfig;
            let ValidateAuthority = true;
            try {
                ValidateAuthority = Boolean(JSON.parse(`${(_a = typedBotFrameworkAuthConfig.ValidateAuthority) !== null && _a !== void 0 ? _a : true}`));
            }
            catch (_err) {
                // no-op
            }
            this.inner = botframework_connector_1.BotFrameworkAuthenticationFactory.create(ChannelService, ValidateAuthority, ToChannelFromBotLoginUrl, ToChannelFromBotOAuthScope, ToBotFromChannelTokenIssuer, OAuthUrl, ToBotFromChannelOpenIdMetadataUrl, ToBotFromEmulatorOpenIdMetadataUrl, CallerId, credentialsFactory !== null && credentialsFactory !== void 0 ? credentialsFactory : new configurationServiceClientCredentialFactory_1.ConfigurationServiceClientCredentialFactory(typedBotFrameworkAuthConfig), authConfiguration !== null && authConfiguration !== void 0 ? authConfiguration : { requiredEndorsements: [] }, botFrameworkClientFetch, connectorClientOptions);
        }
        catch (err) {
            // Throw a new error with the validation details prominently featured.
            if (z.instanceof(z.ZodError).check(err)) {
                throw new Error(JSON.stringify(err.errors, null, 2));
            }
            throw err;
        }
    }
    /**
     * Authenticate Bot Framework Protocol requests to Skills.
     *
     * @param authHeader The http auth header received in the skill request.
     * @returns  {Promise<ClaimsIdentity>} A [ClaimsIdentity](xref:botframework-connector.ClaimsIdentity).
     */
    authenticateChannelRequest(authHeader) {
        return this.inner.authenticateChannelRequest(authHeader);
    }
    /**
     * Validate Bot Framework Protocol requests.
     *
     * @param activity The inbound Activity.
     * @param authHeader The HTTP auth header.
     * @returns {Promise<AuthenticateRequestResult>} An [AuthenticateRequestResult](xref:botframework-connector.AuthenticateRequestResult).
     */
    authenticateRequest(activity, authHeader) {
        return this.inner.authenticateRequest(activity, authHeader);
    }
    /**
     * Validate Bot Framework Protocol requests.
     *
     * @param authHeader The HTTP auth header.
     * @param channelIdHeader The channel ID HTTP header.
     * @returns {Promise<AuthenticateRequestResult>} An [AuthenticateRequestResult](xref:botframework-connector.AuthenticateRequestResult).
     */
    authenticateStreamingRequest(authHeader, channelIdHeader) {
        return this.inner.authenticateStreamingRequest(authHeader, channelIdHeader);
    }
    /**
     * Creates a BotFrameworkClient for calling Skills.
     *
     * @returns A [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
     */
    createBotFrameworkClient() {
        return this.inner.createBotFrameworkClient();
    }
    /**
     * Creates a ConnectorFactory that can be used to create ConnectorClients that can use credentials from this particular Cloud Environment.
     *
     * @param claimsIdentity The inbound Activity's ClaimsIdentity.
     * @returns A [ConnectorFactory](xref:botframework-connector.ConnectorFactory).
     */
    createConnectorFactory(claimsIdentity) {
        return this.inner.createConnectorFactory(claimsIdentity);
    }
    /**
     * Creates the appropriate UserTokenClient instance.
     *
     * @param claimsIdentity The inbound Activity's ClaimsIdentity.
     * @returns {Promise<UserTokenClient>} An [UserTokenClient](xref:botframework-connector.UserTokenClient).
     */
    createUserTokenClient(claimsIdentity) {
        return this.inner.createUserTokenClient(claimsIdentity);
    }
}
exports.ConfigurationBotFrameworkAuthentication = ConfigurationBotFrameworkAuthentication;
/**
 * Creates a new instance of the [ConfigurationBotFrameworkAuthentication](xref:botbuilder-core.ConfigurationBotFrameworkAuthentication) class.
 *
 * @remarks
 * The [Configuration](xref:botbuilder-dialogs-adaptive-runtime-core.Configuration) instance provided to the constructor should
 * have the desired authentication values available at the root, using the properties of [ConfigurationBotFrameworkAuthenticationOptions](xref:botbuilder-core.ConfigurationBotFrameworkAuthenticationOptions) as its keys.
 * @param configuration A [Configuration](xref:botbuilder-dialogs-adaptive-runtime-core.Configuration) instance.
 * @param credentialsFactory A [ServiceClientCredentialsFactory](xref:botframework-connector.ServiceClientCredentialsFactory) instance.
 * @param authConfiguration A [Configuration](xref:botframework-connector.AuthenticationConfiguration) object.
 * @param botFrameworkClientFetch A custom Fetch implementation to be used in the [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
 * @param connectorClientOptions A [ConnectorClientOptions](xref:botframework-connector.ConnectorClientOptions) object.
 * @returns A [ConfigurationBotFrameworkAuthentication](xref:botbuilder-core.ConfigurationBotFrameworkAuthentication) instance.
 */
function createBotFrameworkAuthenticationFromConfiguration(configuration, credentialsFactory, authConfiguration, botFrameworkClientFetch, connectorClientOptions = {}) {
    const botFrameworkAuthConfig = configuration === null || configuration === void 0 ? void 0 : configuration.get();
    return new ConfigurationBotFrameworkAuthentication(botFrameworkAuthConfig, credentialsFactory, authConfiguration, botFrameworkClientFetch, connectorClientOptions);
}
exports.createBotFrameworkAuthenticationFromConfiguration = createBotFrameworkAuthenticationFromConfiguration;
//# sourceMappingURL=configurationBotFrameworkAuthentication.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShowTypingMiddleware = void 0;
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botframework_schema_1 = require("botframework-schema");
const botframework_connector_1 = require("botframework-connector");
const turnContext_1 = require("./turnContext");
/**
 * Middleware that will send a typing indicator automatically for each message.
 *
 * @remarks
 * When added, this middleware will send typing activities back to the user when a Message activity
 * is received to let them know that the bot has received the message and is working on the response.
 * You can specify a delay in milliseconds before the first typing activity is sent and then a frequency,
 * also in milliseconds which determines how often another typing activity is sent. Typing activities
 * will continue to be sent until your bot sends another message back to the user
 */
class ShowTypingMiddleware {
    /**
     * Create the SendTypingIndicator middleware
     *
     * @param delay {number} Number of milliseconds to wait before sending the first typing indicator.
     * @param period {number} Number of milliseconds to wait before sending each following indicator.
     */
    constructor(delay = 500, period = 2000) {
        this.delay = delay;
        this.period = period;
        if (delay < 0) {
            throw new Error('Delay must be greater than or equal to zero');
        }
        if (period <= 0) {
            throw new Error('Repeat period must be greater than zero');
        }
    }
    /**
     * Processes an incoming activity.
     *
     * @param context {TurnContext} An incoming TurnContext object.
     * @param next {function} The next delegate function.
     */
    onTurn(context, next) {
        return __awaiter(this, void 0, void 0, function* () {
            let finished = false;
            let timeout;
            const scheduleIndicator = (delay = this.delay) => {
                timeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    if (!finished) {
                        try {
                            yield this.sendTypingActivity(context);
                        }
                        catch (err) {
                            if (context.adapter && context.adapter.onTurnError) {
                                yield context.adapter.onTurnError(context, err);
                            }
                            else {
                                throw err;
                            }
                        }
                        scheduleIndicator(this.period);
                    }
                }), delay);
            };
            if (!this.isSkillBot(context) && context.activity.type === botframework_schema_1.ActivityTypes.Message) {
                finished = false;
                scheduleIndicator();
            }
            // Execute remaining middleware inside try/finally to ensure we eventually clear timeouts
            try {
                yield next();
            }
            finally {
                finished = true;
                if (timeout)
                    clearTimeout(timeout);
            }
        });
    }
    isSkillBot(context) {
        const identity = context.turnState.get(context.adapter.BotIdentityKey);
        return identity && botframework_connector_1.SkillValidation.isSkillClaim(identity.claims);
    }
    /**
     * @private
     */
    sendTypingActivity(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sending the Activity directly via the Adapter avoids other middleware and avoids setting the
            // responded flag. However this also requires that the conversation reference details are explicitly added.
            const conversationReference = turnContext_1.TurnContext.getConversationReference(context.activity);
            const typingActivity = turnContext_1.TurnContext.applyConversationReference({
                type: botframework_schema_1.ActivityTypes.Typing,
                relatesTo: context.activity.relatesTo,
            }, conversationReference);
            yield context.adapter.sendActivities(context, [typingActivity]);
        });
    }
}
exports.ShowTypingMiddleware = ShowTypingMiddleware;
//# sourceMappingURL=showTypingMiddleware.js.map
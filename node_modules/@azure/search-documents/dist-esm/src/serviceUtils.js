// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __rest } from "tslib";
import { isComplexField, } from "./serviceModels";
export function convertSkillsToPublic(skills) {
    if (!skills) {
        return skills;
    }
    const result = [];
    for (const skill of skills) {
        switch (skill.odatatype) {
            case "#Microsoft.Skills.Util.ConditionalSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.KeyPhraseExtractionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Vision.OcrSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Vision.ImageAnalysisSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.LanguageDetectionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Util.ShaperSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.MergeSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.EntityRecognitionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.SentimentSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.SplitSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.PIIDetectionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.V3.EntityRecognitionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.V3.EntityLinkingSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.V3.SentimentSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.TranslationSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Custom.WebApiSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.CustomEntityLookupSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Util.DocumentExtractionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Custom.AmlSkill":
                result.push(skill);
                break;
        }
    }
    return result;
}
export function convertCognitiveServicesAccountToGenerated(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    return cognitiveServicesAccount;
}
export function convertCognitiveServicesAccountToPublic(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    if (cognitiveServicesAccount.odatatype === "#Microsoft.Azure.Search.DefaultCognitiveServices") {
        return cognitiveServicesAccount;
    }
    else {
        return cognitiveServicesAccount;
    }
}
export function convertTokenFiltersToGenerated(tokenFilters) {
    if (!tokenFilters) {
        return tokenFilters;
    }
    const result = [];
    for (const filter of tokenFilters) {
        result.push(filter);
    }
    return result;
}
export function convertAnalyzersToGenerated(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags ? analyzer.flags.join("|") : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizerName: analyzer.tokenizerName }));
                break;
        }
    }
    return result;
}
export function convertAnalyzersToPublic(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags
                        ? analyzer.flags.split("|")
                        : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizerName: analyzer.tokenizerName }));
                break;
        }
    }
    return result;
}
export function convertFieldsToPublic(fields) {
    if (!fields) {
        return fields;
    }
    return fields.map((field) => {
        if (field.type === "Collection(Edm.ComplexType)" || field.type === "Edm.ComplexType") {
            const result = {
                name: field.name,
                type: field.type,
                fields: convertFieldsToPublic(field.fields),
            };
            return result;
        }
        else {
            const type = field.type;
            const analyzerName = field.analyzer;
            const searchAnalyzerName = field.searchAnalyzer;
            const indexAnalyzerName = field.indexAnalyzer;
            const synonymMapNames = field.synonymMaps;
            const normalizerName = field.normalizer;
            const { retrievable } = field, restField = __rest(field, ["retrievable"]);
            const hidden = typeof retrievable === "boolean" ? !retrievable : retrievable;
            const result = Object.assign(Object.assign({}, restField), { type,
                hidden,
                analyzerName,
                searchAnalyzerName,
                indexAnalyzerName,
                synonymMapNames,
                normalizerName });
            return result;
        }
    });
}
export function convertFieldsToGenerated(fields) {
    return fields.map((field) => {
        var _a, _b, _c, _d;
        if (isComplexField(field)) {
            return {
                name: field.name,
                type: field.type,
                fields: convertFieldsToGenerated(field.fields),
            };
        }
        else {
            const { hidden } = field, restField = __rest(field, ["hidden"]);
            const retrievable = typeof hidden === "boolean" ? !hidden : hidden;
            return Object.assign(Object.assign({}, restField), { retrievable, 
                // modify API defaults to use less storage for simple types
                searchable: (_a = field.searchable) !== null && _a !== void 0 ? _a : false, filterable: (_b = field.filterable) !== null && _b !== void 0 ? _b : false, facetable: (_c = field.facetable) !== null && _c !== void 0 ? _c : false, sortable: (_d = field.sortable) !== null && _d !== void 0 ? _d : false, analyzer: field.analyzerName, searchAnalyzer: field.searchAnalyzerName, indexAnalyzer: field.indexAnalyzerName, synonymMaps: field.synonymMapNames, normalizer: field.normalizerName });
        }
    });
}
export function convertTokenizersToGenerated(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags ? tokenizer.flags.join("|") : undefined }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
export function convertTokenizersToPublic(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags
                    ? tokenizer.flags.split("|")
                    : undefined }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
export function convertSimilarityToGenerated(similarity) {
    if (!similarity) {
        return similarity;
    }
    return similarity;
}
export function convertSimilarityToPublic(similarity) {
    if (!similarity) {
        return similarity;
    }
    if (similarity.odatatype === "#Microsoft.Azure.Search.ClassicSimilarity") {
        return similarity;
    }
    else {
        return similarity;
    }
}
export function convertEncryptionKeyToPublic(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUrl: encryptionKey.vaultUri,
        identity: convertSearchIndexerDataIdentityToPublic(encryptionKey.identity),
    };
    if (encryptionKey.accessCredentials) {
        result.applicationId = encryptionKey.accessCredentials.applicationId;
        result.applicationSecret = encryptionKey.accessCredentials.applicationSecret;
    }
    return result;
}
export function convertEncryptionKeyToGenerated(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUri: encryptionKey.vaultUrl,
        identity: encryptionKey.identity,
    };
    if (encryptionKey.applicationId) {
        result.accessCredentials = {
            applicationId: encryptionKey.applicationId,
            applicationSecret: encryptionKey.applicationSecret,
        };
    }
    return result;
}
export function generatedIndexToPublicIndex(generatedIndex) {
    return {
        name: generatedIndex.name,
        defaultScoringProfile: generatedIndex.defaultScoringProfile,
        corsOptions: generatedIndex.corsOptions,
        suggesters: generatedIndex.suggesters,
        encryptionKey: convertEncryptionKeyToPublic(generatedIndex.encryptionKey),
        etag: generatedIndex.etag,
        analyzers: convertAnalyzersToPublic(generatedIndex.analyzers),
        tokenizers: convertTokenizersToPublic(generatedIndex.tokenizers),
        tokenFilters: generatedIndex.tokenFilters,
        charFilters: generatedIndex.charFilters,
        normalizers: generatedIndex.normalizers,
        scoringProfiles: generatedIndex.scoringProfiles,
        fields: convertFieldsToPublic(generatedIndex.fields),
        similarity: convertSimilarityToPublic(generatedIndex.similarity),
        semanticSettings: generatedIndex.semanticSettings,
        vectorSearch: generatedIndex.vectorSearch,
    };
}
export function generatedSearchResultToPublicSearchResult(results) {
    const returnValues = results.map((result) => {
        const { _score, _highlights, rerankerScore, captions, documentDebugInfo } = result, restProps = __rest(result, ["_score", "_highlights", "rerankerScore", "captions", "documentDebugInfo"]);
        const doc = Object.assign({}, restProps);
        const obj = {
            score: _score,
            highlights: _highlights,
            rerankerScore,
            captions,
            document: doc,
            documentDebugInfo,
        };
        return obj;
    });
    return returnValues;
}
export function generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(searchDocumentsResult) {
    const results = searchDocumentsResult.results.map((element) => {
        const { _text } = element, restProps = __rest(element, ["_text"]);
        const doc = Object.assign({}, restProps);
        const obj = {
            text: _text,
            document: doc,
        };
        return obj;
    });
    const result = {
        results: results,
        coverage: searchDocumentsResult.coverage,
    };
    return result;
}
export function publicIndexToGeneratedIndex(index) {
    const { encryptionKey, tokenFilters, analyzers, tokenizers, fields, similarity } = index;
    return Object.assign(Object.assign({}, index), { encryptionKey: convertEncryptionKeyToGenerated(encryptionKey), tokenFilters: convertTokenFiltersToGenerated(tokenFilters), analyzers: convertAnalyzersToGenerated(analyzers), tokenizers: convertTokenizersToGenerated(tokenizers), fields: convertFieldsToGenerated(fields), similarity: convertSimilarityToGenerated(similarity) });
}
export function generatedSkillsetToPublicSkillset(generatedSkillset) {
    return {
        name: generatedSkillset.name,
        description: generatedSkillset.description,
        skills: convertSkillsToPublic(generatedSkillset.skills),
        cognitiveServicesAccount: convertCognitiveServicesAccountToPublic(generatedSkillset.cognitiveServicesAccount),
        knowledgeStore: convertKnowledgeStoreToPublic(generatedSkillset.knowledgeStore),
        etag: generatedSkillset.etag,
        encryptionKey: convertEncryptionKeyToPublic(generatedSkillset.encryptionKey),
    };
}
export function publicSkillsetToGeneratedSkillset(skillset) {
    return {
        name: skillset.name,
        description: skillset.description,
        etag: skillset.etag,
        skills: skillset.skills,
        cognitiveServicesAccount: convertCognitiveServicesAccountToGenerated(skillset.cognitiveServicesAccount),
        knowledgeStore: skillset.knowledgeStore,
        encryptionKey: convertEncryptionKeyToGenerated(skillset.encryptionKey),
    };
}
export function generatedSynonymMapToPublicSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        encryptionKey: convertEncryptionKeyToPublic(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: [],
    };
    if (synonymMap.synonyms) {
        result.synonyms = synonymMap.synonyms.split("\n");
    }
    return result;
}
export function publicSynonymMapToGeneratedSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        format: "solr",
        encryptionKey: convertEncryptionKeyToGenerated(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: synonymMap.synonyms.join("\n"),
    };
    result.encryptionKey = convertEncryptionKeyToGenerated(synonymMap.encryptionKey);
    return result;
}
export function publicSearchIndexerToGeneratedSearchIndexer(indexer) {
    return Object.assign(Object.assign({}, indexer), { encryptionKey: convertEncryptionKeyToGenerated(indexer.encryptionKey) });
}
export function generatedSearchIndexerToPublicSearchIndexer(indexer) {
    return Object.assign(Object.assign({}, indexer), { encryptionKey: convertEncryptionKeyToPublic(indexer.encryptionKey), cache: convertSearchIndexerCacheToPublic(indexer.cache) });
}
export function generatedSearchRequestToPublicSearchRequest(request) {
    const { semanticErrorHandling, debug, vectors } = request, props = __rest(request, ["semanticErrorHandling", "debug", "vectors"]);
    const publicRequest = Object.assign({ semanticErrorHandlingMode: semanticErrorHandling, debugMode: debug, vectors: vectors === null || vectors === void 0 ? void 0 : vectors.map((convertVectorToPublic)).filter((v) => v !== undefined) }, props);
    return publicRequest;
}
export function publicDataSourceToGeneratedDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.description,
        type: dataSource.type,
        credentials: {
            connectionString: dataSource.connectionString,
        },
        container: dataSource.container,
        identity: dataSource.identity,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: dataSource.dataChangeDetectionPolicy,
        dataDeletionDetectionPolicy: dataSource.dataDeletionDetectionPolicy,
        encryptionKey: convertEncryptionKeyToGenerated(dataSource.encryptionKey),
    };
}
export function generatedDataSourceToPublicDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.name,
        type: dataSource.type,
        connectionString: dataSource.credentials.connectionString,
        container: dataSource.container,
        identity: convertSearchIndexerDataIdentityToPublic(dataSource.identity),
        etag: dataSource.etag,
        dataChangeDetectionPolicy: convertDataChangeDetectionPolicyToPublic(dataSource.dataChangeDetectionPolicy),
        dataDeletionDetectionPolicy: convertDataDeletionDetectionPolicyToPublic(dataSource.dataDeletionDetectionPolicy),
        encryptionKey: convertEncryptionKeyToPublic(dataSource.encryptionKey),
    };
}
export function convertSearchIndexerDataIdentityToPublic(searchIndexerDataIdentity) {
    if (!searchIndexerDataIdentity) {
        return searchIndexerDataIdentity;
    }
    if (searchIndexerDataIdentity.odatatype === "#Microsoft.Azure.Search.DataNoneIdentity") {
        return searchIndexerDataIdentity;
    }
    else {
        return searchIndexerDataIdentity;
    }
}
export function convertDataChangeDetectionPolicyToPublic(dataChangeDetectionPolicy) {
    if (!dataChangeDetectionPolicy) {
        return dataChangeDetectionPolicy;
    }
    if (dataChangeDetectionPolicy.odatatype ===
        "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy") {
        return dataChangeDetectionPolicy;
    }
    else {
        return dataChangeDetectionPolicy;
    }
}
export function convertDataDeletionDetectionPolicyToPublic(dataDeletionDetectionPolicy) {
    if (!dataDeletionDetectionPolicy) {
        return dataDeletionDetectionPolicy;
    }
    return dataDeletionDetectionPolicy;
}
function convertVectorToPublic(vector) {
    var _a;
    if (!vector) {
        return vector;
    }
    const fields = (_a = vector.fields) === null || _a === void 0 ? void 0 : _a.split(",");
    return Object.assign(Object.assign({}, vector), { fields });
}
export function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}
/**
 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
 * @param timeInMs - The number of milliseconds to be delayed.
 * @returns Promise that is resolved after timeInMs
 */
export function delay(timeInMs) {
    return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));
}
export const serviceVersions = ["2020-06-30", "2023-07-01-Preview"];
export const defaultServiceVersion = "2023-07-01-Preview";
function convertKnowledgeStoreToPublic(knowledgeStore) {
    if (!knowledgeStore) {
        return knowledgeStore;
    }
    return Object.assign(Object.assign({}, knowledgeStore), { identity: convertSearchIndexerDataIdentityToPublic(knowledgeStore.identity) });
}
function convertSearchIndexerCacheToPublic(cache) {
    if (!cache) {
        return cache;
    }
    return Object.assign(Object.assign({}, cache), { identity: convertSearchIndexerDataIdentityToPublic(cache.identity) });
}
//# sourceMappingURL=serviceUtils.js.map
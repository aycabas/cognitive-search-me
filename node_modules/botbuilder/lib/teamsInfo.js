"use strict";
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsInfo = void 0;
const botbuilder_core_1 = require("botbuilder-core");
const botframework_connector_1 = require("botframework-connector");
const cloudAdapter_1 = require("./cloudAdapter");
const teamsActivityHelpers_1 = require("./teamsActivityHelpers");
/**
 * Provides utility methods for the events and interactions that occur within Microsoft Teams.
 */
class TeamsInfo {
    /**
     * Gets the meeting participant for the given meeting id and participant id. This only works in
     * teams scoped meeting conversations.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param meetingId The meeting ID to fetch
     * @param participantId The participant ID to fetch
     * @param tenantId The tenant ID to use when scoping the request
     * @returns The [TeamsMeetingParticipant](xref:botbuilder-core.TeamsMeetingParticipant) fetched
     */
    static getMeetingParticipant(context, meetingId, participantId, tenantId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new Error('context is required.');
            }
            const activity = context.activity;
            if (meetingId == null) {
                const meeting = (0, teamsActivityHelpers_1.teamsGetTeamMeetingInfo)(activity);
                meetingId = meeting === null || meeting === void 0 ? void 0 : meeting.id;
            }
            if (!meetingId) {
                throw new Error('meetingId is required.');
            }
            if (participantId == null) {
                const from = activity.from;
                participantId = from === null || from === void 0 ? void 0 : from.aadObjectId;
            }
            if (!participantId) {
                throw new Error('participantId is required.');
            }
            // Note: === undefined here because tenant ID is technically an optional parameter. If a user specifically
            // wants to disable defaulting of tenant ID they can pass `null`.
            if (tenantId === undefined) {
                const tenant = (0, teamsActivityHelpers_1.teamsGetTenant)(activity);
                tenantId = tenant === null || tenant === void 0 ? void 0 : tenant.id;
            }
            return this.getTeamsConnectorClient(context).teams.fetchMeetingParticipant(meetingId, participantId, {
                tenantId,
            });
        });
    }
    /**
     * Gets the information for the given meeting id.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param meetingId The BASE64-encoded id of the Teams meeting.
     * @returns The [TeamsMeetingInfo](xref:botbuilder-core.TeamsMeetingInfo) fetched
     */
    static getMeetingInfo(context, meetingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new Error('context is required.');
            }
            const activity = context.activity;
            if (meetingId == null) {
                const meeting = (0, teamsActivityHelpers_1.teamsGetTeamMeetingInfo)(activity);
                meetingId = meeting === null || meeting === void 0 ? void 0 : meeting.id;
            }
            if (!meetingId) {
                throw new Error('meetingId or TurnContext containing meetingId is required.');
            }
            return this.getTeamsConnectorClient(context).teams.fetchMeetingInfo(meetingId);
        });
    }
    /**
     * Gets the details for the given team id. This only works in teams scoped conversations.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param teamId The id of the Teams team.
     * @returns The [TeamDetails](xref:botbuilder-core.TeamDetails) fetched
     */
    static getTeamDetails(context, teamId) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = teamId || this.getTeamId(context);
            if (!t) {
                throw new Error('This method is only valid within the scope of a MS Teams Team.');
            }
            return yield this.getTeamsConnectorClient(context).teams.fetchTeamDetails(t);
        });
    }
    /**
     * Creates a new thread in a Teams chat and sends an [Activity](xref:botframework-schema.Activity) to that new thread.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param activity The [Activity](xref:botframework-schema.Activity) to send.
     * @param teamsChannelId The Team's Channel ID, note this is distinct from the Bot Framework activity property with same name.
     * @param botAppId The bot's appId. This is only used when context.adapter is an instance of CloudAdapter.
     * @returns The [ConversationReference](xref:botframework-schema.ConversationReference) and the id of the [Activity](xref:botframework-schema.Activity) (if sent).
     */
    static sendMessageToTeamsChannel(context, activity, teamsChannelId, botAppId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new Error('TurnContext cannot be null');
            }
            if (!activity) {
                throw new Error('Activity cannot be null');
            }
            if (!teamsChannelId || !teamsChannelId) {
                throw new Error('The teamsChannelId cannot be null or empty');
            }
            const convoParams = {
                isGroup: true,
                channelData: {
                    channel: {
                        id: teamsChannelId,
                    },
                },
                activity: activity,
            };
            let conversationReference;
            let newActivityId;
            if (botAppId && context.adapter instanceof cloudAdapter_1.CloudAdapter) {
                yield context.adapter.createConversationAsync(botAppId, botbuilder_core_1.Channels.Msteams, context.activity.serviceUrl, null, convoParams, (turnContext) => __awaiter(this, void 0, void 0, function* () {
                    conversationReference = botbuilder_core_1.TurnContext.getConversationReference(turnContext.activity);
                    newActivityId = turnContext.activity.id;
                }));
            }
            else {
                const connectorClient = context.adapter.createConnectorClient(context.activity.serviceUrl);
                const conversationResourceResponse = yield connectorClient.conversations.createConversation(convoParams);
                conversationReference = botbuilder_core_1.TurnContext.getConversationReference(context.activity);
                conversationReference.conversation.id = conversationResourceResponse.id;
                newActivityId = conversationResourceResponse.activityId;
            }
            return [conversationReference, newActivityId];
        });
    }
    /**
     * Returns a list of channels in a Team. This only works in teams scoped conversations.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param teamId ID of the Teams team.
     * @returns The list of [ChannelInfo](xref:botframework-schema.ChannelInfo) objects with the conversations.
     */
    static getTeamChannels(context, teamId) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = teamId || this.getTeamId(context);
            if (!t) {
                throw new Error('This method is only valid within the scope of a MS Teams Team.');
            }
            const channelList = yield this.getTeamsConnectorClient(context).teams.fetchChannelList(t);
            return channelList.conversations;
        });
    }
    /**
     * Gets the conversation members of a one-on-one or group chat.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @returns The list of [TeamsChannelAccount](xref:botframework-schema.TeamsChannelAccount).
     *
     * @deprecated Use `getPagedTeamMembers` instead.
     */
    static getMembers(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const teamId = this.getTeamId(context);
            if (teamId) {
                return yield this.getTeamMembers(context, teamId);
            }
            else {
                const conversation = context.activity.conversation;
                const conversationId = conversation && conversation.id ? conversation.id : undefined;
                return yield this.getMembersInternal(this.getConnectorClient(context), conversationId);
            }
        });
    }
    /**
     * Gets a pagined list of members of one-on-one, group, or team conversation.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param pageSize Suggested number of entries on a page.
     * @param continuationToken A continuation token.
     * @returns The [TeamsPagedMembersResult](xref:botframework-schema.TeamsPagedMembersResult) with the list of members.
     */
    static getPagedMembers(context, pageSize, continuationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const teamId = this.getTeamId(context);
            const options = {
                continuationToken: continuationToken,
                pageSize: pageSize,
            };
            if (teamId) {
                return yield this.getPagedTeamMembers(context, teamId, pageSize, continuationToken);
            }
            else {
                const conversation = context.activity.conversation;
                const conversationId = conversation && conversation.id ? conversation.id : undefined;
                return yield this.getPagedMembersInternal(this.getConnectorClient(context), conversationId, options);
            }
        });
    }
    /**
     * Gets the account of a single conversation member.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param userId ID of the user in question.
     * @returns The [TeamsChannelAccount](xref:botframework-schema.TeamsChannelAccount) of the member.
     */
    static getMember(context, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const teamId = this.getTeamId(context);
            if (teamId) {
                return yield this.getTeamMember(context, teamId, userId);
            }
            else {
                const conversation = context.activity.conversation;
                const conversationId = conversation && conversation.id ? conversation.id : undefined;
                return yield this.getMemberInternal(this.getConnectorClient(context), conversationId, userId);
            }
        });
    }
    /**
     * Gets the list of [TeamsChannelAccount](xref:botframework-schema.TeamsChannelAccount) within a team.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param teamId ID of the Teams team.
     * @returns The list of [TeamsChannelAccount](xref:botframework-schema.TeamsChannelAccount) of the members.
     *
     * @deprecated Use `getPagedTeamMembers` instead.
     */
    static getTeamMembers(context, teamId) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = teamId || this.getTeamId(context);
            if (!t) {
                throw new Error('This method is only valid within the scope of a MS Teams Team.');
            }
            return yield this.getMembersInternal(this.getConnectorClient(context), t);
        });
    }
    /**
     * Gets a paginated list of members of a team.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param teamId ID of the Teams team.
     * @param pageSize The number of entries on the page.
     * @param continuationToken The continuationToken token.
     * @returns A [TeamsPagedMembersResult](xref:botframework-schema.TeamsPagedMembersResult) with the list of members.
     */
    static getPagedTeamMembers(context, teamId, pageSize, continuationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = teamId || this.getTeamId(context);
            if (!t) {
                throw new Error('This method is only valid within the scope of a MS Teams Team.');
            }
            const options = {
                continuationToken: continuationToken,
                pageSize: pageSize,
            };
            return yield this.getPagedMembersInternal(this.getConnectorClient(context), t, options);
        });
    }
    /**
     * Gets the account of a member in a teams scoped conversation.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param teamId ID of the Teams team.
     * @param userId ID of the Teams user.
     * @returns The [TeamsChannelAccount](xref:botframework-schema.TeamsChannelAccount) of the member.
     */
    static getTeamMember(context, teamId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = teamId || this.getTeamId(context);
            if (!t) {
                throw new Error('This method is only valid within the scope of a MS Teams Team.');
            }
            return yield this.getMemberInternal(this.getConnectorClient(context), t, userId);
        });
    }
    /**
     * Sends a meeting notification to specific users in a Teams meeting.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) for this turn.
     * @param notification The meeting notification payload.
     * @param meetingId Id of the Teams meeting.
     * @returns Promise with either an empty object if notifications were successfully sent to all recipients or
     * [MeetingNotificationResponse](xref:botframework-schema.MeetingNotificationResponse) if notifications
     * were sent to some but not all recipients.
     */
    static sendMeetingNotification(context, notification, meetingId) {
        return __awaiter(this, void 0, void 0, function* () {
            const activity = context.activity;
            if (meetingId == null) {
                const meeting = (0, teamsActivityHelpers_1.teamsGetTeamMeetingInfo)(activity);
                meetingId = meeting === null || meeting === void 0 ? void 0 : meeting.id;
            }
            if (!meetingId) {
                throw new Error('meetingId is required.');
            }
            return yield this.getTeamsConnectorClient(context).teams.sendMeetingNotification(meetingId, notification);
        });
    }
    /**
     * @private
     */
    static getMembersInternal(connectorClient, conversationId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversationId) {
                throw new Error('The getMembers operation needs a valid conversationId.');
            }
            const teamMembers = yield connectorClient.conversations.getConversationMembers(conversationId);
            teamMembers.forEach((member) => {
                member.aadObjectId = member.objectId;
            });
            return teamMembers;
        });
    }
    /**
     * @private
     */
    static getPagedMembersInternal(connectorClient, conversationId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversationId) {
                throw new Error('The getPagedMembers operation needs a valid conversationId.');
            }
            const pagedMembersResult = yield connectorClient.conversations.getConversationPagedMembers(conversationId, options);
            const teamsPagedMembersResult = {
                continuationToken: pagedMembersResult.continuationToken,
                members: pagedMembersResult.members,
            };
            return teamsPagedMembersResult;
        });
    }
    /**
     * @private
     */
    static getMemberInternal(connectorClient, conversationId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversationId) {
                throw new Error('The getMember operation needs a valid conversationId.');
            }
            if (!userId) {
                throw new Error('The getMember operation needs a valid userId.');
            }
            const teamMember = yield connectorClient.conversations.getConversationMember(conversationId, userId);
            return teamMember;
        });
    }
    /**
     * @private
     */
    static getTeamId(context) {
        if (!context) {
            throw new Error('Missing context parameter');
        }
        if (!context.activity) {
            throw new Error('Missing activity on context');
        }
        const channelData = context.activity.channelData;
        const team = channelData && channelData.team ? channelData.team : undefined;
        const teamId = team && typeof team.id === 'string' ? team.id : undefined;
        return teamId;
    }
    /**
     * @private
     */
    static getConnectorClient(context) {
        var _a;
        const client = context.adapter && 'createConnectorClient' in context.adapter
            ? context.adapter.createConnectorClient(context.activity.serviceUrl)
            : (_a = context.turnState) === null || _a === void 0 ? void 0 : _a.get(context.adapter.ConnectorClientKey);
        if (!client) {
            throw new Error('This method requires a connector client.');
        }
        return client;
    }
    /**
     * @private
     */
    static getTeamsConnectorClient(context) {
        const connectorClient = this.getConnectorClient(context);
        return new botframework_connector_1.TeamsConnectorClient(connectorClient.credentials, { baseUri: context.activity.serviceUrl });
    }
}
exports.TeamsInfo = TeamsInfo;
//# sourceMappingURL=teamsInfo.js.map
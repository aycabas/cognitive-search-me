"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelServiceHandler = void 0;
const channelServiceHandlerBase_1 = require("./channelServiceHandlerBase");
const statusCodeError_1 = require("./statusCodeError");
const botbuilder_core_1 = require("botbuilder-core");
const botframework_connector_1 = require("botframework-connector");
/**
 * @deprecated Use `CloudChannelServiceHandler` instead.
 * The ChannelServiceHandler implements API to forward activity to a skill and
 * implements routing ChannelAPI calls from the Skill up through the bot/adapter.
 */
class ChannelServiceHandler extends channelServiceHandlerBase_1.ChannelServiceHandlerBase {
    /**
     * Initializes a new instance of the ChannelServiceHandler class, using a credential provider.
     *
     * @param credentialProvider The credential provider.
     * @param authConfig The authentication configuration.
     * @param channelService A string representing the channel provider.
     */
    constructor(credentialProvider, authConfig, channelService = process.env[botframework_connector_1.AuthenticationConstants.ChannelService]) {
        super();
        this.credentialProvider = credentialProvider;
        this.authConfig = authConfig;
        this.channelService = channelService;
        if (!credentialProvider) {
            throw new Error('ChannelServiceHandler(): missing credentialProvider');
        }
        if (!authConfig) {
            throw new Error('ChannelServiceHandler(): missing authConfig');
        }
    }
    authenticate(authHeader) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!authHeader) {
                const isAuthDisabled = yield this.credentialProvider.isAuthenticationDisabled();
                if (!isAuthDisabled) {
                    throw new statusCodeError_1.StatusCodeError(botbuilder_core_1.StatusCodes.UNAUTHORIZED);
                }
                // In the scenario where Auth is disabled, we still want to have the
                // IsAuthenticated flag set in the ClaimsIdentity. To do this requires
                // adding in an empty claim.
                // Since ChannelServiceHandler calls are always a skill callback call, we set the skill claim too.
                return botframework_connector_1.SkillValidation.createAnonymousSkillClaim();
            }
            return botframework_connector_1.JwtTokenValidation.validateAuthHeader(authHeader, this.credentialProvider, this.channelService, 'unknown', undefined, this.authConfig);
        });
    }
}
exports.ChannelServiceHandler = ChannelServiceHandler;
//# sourceMappingURL=channelServiceHandler.js.map
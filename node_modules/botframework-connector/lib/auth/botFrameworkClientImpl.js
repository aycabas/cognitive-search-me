"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotFrameworkClientImpl = void 0;
const z = require("zod");
const axios_1 = require("axios");
const botframework_schema_1 = require("botframework-schema");
const conversationConstants_1 = require("../conversationConstants");
const connectorFactoryImpl_1 = require("./connectorFactoryImpl");
const ms_rest_js_1 = require("@azure/ms-rest-js");
const assert_1 = require("assert");
const botFrameworkClientFetchImpl = (input, init) => __awaiter(void 0, void 0, void 0, function* () {
    const url = z.string().parse(input);
    const { body, headers } = z.object({ body: z.string(), headers: z.record(z.string()).optional() }).parse(init);
    const response = yield axios_1.default.post(url, JSON.parse(body), {
        headers,
        validateStatus: () => true,
    });
    return {
        status: response.status,
        json: () => __awaiter(void 0, void 0, void 0, function* () { return response.data; }),
    };
});
/**
 * @internal
 * Implementation of [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
 */
class BotFrameworkClientImpl {
    /**
     * @param credentialsFactory A [ServiceClientCredentialsFactory](xref:botframework-connector.ServiceClientCredentialsFactory) instance.
     * @param loginEndpoint The login url.
     * @param botFrameworkClientFetch A custom Fetch implementation to be used in the [BotFrameworkClient](xref:botframework-connector.BotFrameworkClient).
     */
    constructor(credentialsFactory, loginEndpoint, botFrameworkClientFetch = botFrameworkClientFetchImpl) {
        this.credentialsFactory = credentialsFactory;
        this.loginEndpoint = loginEndpoint;
        this.botFrameworkClientFetch = botFrameworkClientFetch;
        (0, assert_1.ok)(typeof botFrameworkClientFetch === 'function');
    }
    /**
     * @template T The type of body in the InvokeResponse.
     * @param fromBotId The MicrosoftAppId of the bot sending the activity.
     * @param toBotId The MicrosoftAppId of the bot receiving the activity.
     * @param toUrl The URL of the bot receiving the activity.
     * @param serviceUrl The callback Url for the skill host.
     * @param conversationId A conversation ID to use for the conversation with the skill.
     * @param activity The Activity to send to forward.
     * @returns {Promise<InvokeResponse<T>>} A promise representing the asynchronous operation.
     */
    postActivity(fromBotId, toBotId, toUrl, serviceUrl, conversationId, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            z.object({
                fromBotId: z.string().optional(),
                toBotId: z.string().optional(),
                toUrl: z.string(),
                serviceUrl: z.string(),
                conversationId: z.string(),
                activity: z.record(z.unknown()),
            }).parse({
                fromBotId,
                toBotId,
                toUrl,
                serviceUrl,
                conversationId,
                activity,
            });
            const credentials = yield this.credentialsFactory.createCredentials(fromBotId, toBotId, this.loginEndpoint, true);
            // Capture current activity settings before changing them.
            // TODO: DO we need to set the activity ID? (events that are created manually don't have it).
            const originalConversationId = activity.conversation.id;
            const originalServiceUrl = activity.serviceUrl;
            const originalRelatesTo = activity.relatesTo;
            const originalRecipient = activity.recipient;
            try {
                activity.relatesTo = {
                    serviceUrl: activity.serviceUrl,
                    activityId: activity.id,
                    channelId: activity.channelId,
                    conversation: {
                        id: activity.conversation.id,
                        name: activity.conversation.name,
                        conversationType: activity.conversation.conversationType,
                        aadObjectId: activity.conversation.aadObjectId,
                        isGroup: activity.conversation.isGroup,
                        properties: activity.conversation.properties,
                        role: activity.conversation.role,
                        tenantId: activity.conversation.tenantId,
                    },
                    bot: null,
                };
                activity.conversation.id = conversationId;
                activity.serviceUrl = serviceUrl;
                // Fixes: https://github.com/microsoft/botframework-sdk/issues/5785
                if (!activity.recipient) {
                    activity.recipient = {};
                }
                activity.recipient.role = botframework_schema_1.RoleTypes.Skill;
                const webRequest = new ms_rest_js_1.WebResource(toUrl, 'POST', JSON.stringify(activity), undefined, {
                    Accept: 'application/json',
                    [conversationConstants_1.ConversationIdHttpHeaderName]: conversationId,
                    'Content-Type': 'application/json',
                    'User-Agent': connectorFactoryImpl_1.USER_AGENT,
                });
                const request = yield credentials.signRequest(webRequest);
                const config = {
                    body: request.body,
                    headers: request.headers.rawHeaders(),
                };
                const response = yield this.botFrameworkClientFetch(request.url, config);
                return { status: response.status, body: yield response.json() };
            }
            finally {
                // Restore activity properties.
                activity.conversation.id = originalConversationId;
                activity.serviceUrl = originalServiceUrl;
                activity.relatesTo = originalRelatesTo;
                activity.recipient = originalRecipient;
            }
        });
    }
}
exports.BotFrameworkClientImpl = BotFrameworkClientImpl;
//# sourceMappingURL=botFrameworkClientImpl.js.map
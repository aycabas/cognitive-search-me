"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectorFactoryImpl = exports.USER_AGENT = void 0;
const ms_rest_js_1 = require("@azure/ms-rest-js");
const connectorClient_1 = require("../connectorApi/connectorClient");
const connectorFactory_1 = require("./connectorFactory");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageInfo = require('../../package.json');
exports.USER_AGENT = `Microsoft-BotFramework/3.1 ${packageInfo.name}/${packageInfo.version} ${(0, ms_rest_js_1.getDefaultUserAgentValue)()} `;
/**
 * @internal
 * Implementation of [ConnectorFactory](xref:botframework-connector.ConnectorFactory).
 */
class ConnectorFactoryImpl extends connectorFactory_1.ConnectorFactory {
    /**
     * @param appId The AppID.
     * @param toChannelFromBotOAuthScope The to Channel from bot oauth scope.
     * @param loginEndpoint The login url.
     * @param validateAuthority The validate authority value to use.
     * @param credentialFactory A ServiceClientCredentialsFactory to use.
     * @param connectorClientOptions The [ConnectorClientOptions](xref:botframework-connector.ConnectorClientOptions) to use when creating ConnectorClients.
     */
    constructor(appId, toChannelFromBotOAuthScope, loginEndpoint, validateAuthority, credentialFactory, connectorClientOptions = {}) {
        super();
        this.appId = appId;
        this.toChannelFromBotOAuthScope = toChannelFromBotOAuthScope;
        this.loginEndpoint = loginEndpoint;
        this.validateAuthority = validateAuthority;
        this.credentialFactory = credentialFactory;
        this.connectorClientOptions = connectorClientOptions;
    }
    /**
     * @param serviceUrl The client's service URL.
     * @param audience The audience to use for outbound communication. It will vary by cloud environment.
     * @returns The new instance of the ConnectorClient class.
     */
    create(serviceUrl, audience) {
        return __awaiter(this, void 0, void 0, function* () {
            // Use the credentials factory to create credentails specific to this particular cloud environment.
            const credentials = yield this.credentialFactory.createCredentials(this.appId, audience !== null && audience !== void 0 ? audience : this.toChannelFromBotOAuthScope, this.loginEndpoint, this.validateAuthority);
            // A new connector client for making calls against this serviceUrl using credentials derived from the current appId and the specified audience.
            const options = this.getClientOptions(serviceUrl);
            return new connectorClient_1.ConnectorClient(credentials, options);
        });
    }
    getClientOptions(serviceUrl) {
        const _a = this.connectorClientOptions, { requestPolicyFactories } = _a, clientOptions = __rest(_a, ["requestPolicyFactories"]);
        const options = Object.assign({}, { baseUri: serviceUrl }, clientOptions);
        const userAgent = typeof options.userAgent === 'function' ? options.userAgent(exports.USER_AGENT) : options.userAgent;
        const setUserAgent = (0, ms_rest_js_1.userAgentPolicy)({
            value: `${exports.USER_AGENT}${userAgent !== null && userAgent !== void 0 ? userAgent : ''}`,
        });
        const acceptHeader = {
            create: (nextPolicy) => ({
                sendRequest: (httpRequest) => {
                    if (!httpRequest.headers.contains('accept')) {
                        httpRequest.headers.set('accept', '*/*');
                    }
                    return nextPolicy.sendRequest(httpRequest);
                },
            }),
        };
        // Resolve any user request policy factories, then include our user agent via a factory policy
        options.requestPolicyFactories = (defaultRequestPolicyFactories) => {
            let defaultFactories = [];
            if (requestPolicyFactories) {
                if (typeof requestPolicyFactories === 'function') {
                    const newDefaultFactories = requestPolicyFactories(defaultRequestPolicyFactories);
                    if (newDefaultFactories) {
                        defaultFactories = newDefaultFactories;
                    }
                }
                else if (requestPolicyFactories) {
                    defaultFactories = [...requestPolicyFactories];
                }
                // If the user has supplied custom factories, allow them to optionally set user agent
                // before we do.
                defaultFactories = [...defaultFactories, setUserAgent, acceptHeader];
            }
            else {
                // In the case that there are no user supplied factories, inject our user agent as
                // the first policy to ensure none of the default policies override it.
                defaultFactories = [acceptHeader, setUserAgent, ...defaultRequestPolicyFactories];
            }
            return defaultFactories;
        };
        return options;
    }
}
exports.ConnectorFactoryImpl = ConnectorFactoryImpl;
//# sourceMappingURL=connectorFactoryImpl.js.map
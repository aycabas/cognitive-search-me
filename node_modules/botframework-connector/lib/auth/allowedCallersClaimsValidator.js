"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allowedCallersClaimsValidator = void 0;
const jwtTokenValidation_1 = require("./jwtTokenValidation");
const skillValidation_1 = require("./skillValidation");
const assert_1 = require("assert");
/**
 * Create an allowe callers claims validator
 *
 * @param allowedCallers allowed callers of skill
 * @returns claims validator function
 */
function allowedCallersClaimsValidator(allowedCallers) {
    (0, assert_1.ok)(allowedCallers);
    (0, assert_1.ok)(allowedCallers.length);
    const allowed = new Set(allowedCallers);
    return (claims) => __awaiter(this, void 0, void 0, function* () {
        if (!allowed.has('*') && skillValidation_1.SkillValidation.isSkillClaim(claims)) {
            const appId = jwtTokenValidation_1.JwtTokenValidation.getAppIdFromClaims(claims);
            if (!allowed.has(appId)) {
                throw new Error(`Received a request from an application with an appID of "${appId}". To enable requests from this skill, add the skill to your configuration file.`);
            }
        }
    });
}
exports.allowedCallersClaimsValidator = allowedCallersClaimsValidator;
//# sourceMappingURL=allowedCallersClaimsValidator.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeaderSerializer = void 0;
const payloadConstants_1 = require("./payloadConstants");
/**
 * Streaming header serializer
 */
class HeaderSerializer {
    /**
     * Serializes the header into a buffer
     *
     * @param header The header to serialize.
     * @param buffer The buffer into which to serialize the header.
     */
    static serialize(header, buffer) {
        buffer.write(header.payloadType, this.TypeOffset, 1, this.Encoding);
        buffer.write(this.Delimiter, this.TypeDelimiterOffset, 1, this.Encoding);
        buffer.write(this.headerLengthPadder(header.payloadLength, this.LengthLength, '0'), this.LengthOffset, this.LengthLength, this.Encoding);
        buffer.write(this.Delimiter, this.LengthDelimeterOffset, 1, this.Encoding);
        buffer.write(header.id, this.IdOffset);
        buffer.write(this.Delimiter, this.IdDelimeterOffset, 1, this.Encoding);
        buffer.write(header.end ? this.End : this.NotEnd, this.EndOffset);
        buffer.write(this.Terminator, this.TerminatorOffset);
    }
    /**
     * Deserializes a buffer containing header information.
     *
     * @param buffer The buffer from which to obtain the data to deserialize.
     * @returns The deserialized header from the buffer.
     */
    static deserialize(buffer) {
        const jsonBuffer = buffer.toString(this.Encoding);
        const headerArray = jsonBuffer.split(this.Delimiter);
        if (headerArray.length !== 4) {
            throw Error(`Cannot parse header, header is malformed. Header: ${jsonBuffer}`);
        }
        const [payloadType, length, id, headerEnd] = headerArray;
        const end = headerEnd === '1\n';
        const payloadLength = Number(length);
        const header = { end, payloadLength, payloadType, id };
        if (!(header.payloadLength <= payloadConstants_1.PayloadConstants.MaxPayloadLength &&
            header.payloadLength >= payloadConstants_1.PayloadConstants.MinLength)) {
            throw Error(`Header length of ${header.payloadLength} is missing or malformed`);
        }
        if (header.payloadType.length !== this.TypeDelimiterOffset) {
            throw Error(`Header type '${header.payloadType.length}' is missing or malformed.`);
        }
        if (!header.id ||
            !header.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) ||
            header.id.length !== this.IdLength) {
            throw Error(`Header ID '${header.id}' is missing or malformed.`);
        }
        if (!(headerEnd === '0\n' || headerEnd === '1\n')) {
            throw Error(`Header End is missing or not a valid value. Header end: '${headerEnd}'`);
        }
        return header;
    }
    /**
     * Creates a padded string based on a length and character to be padded to.
     *
     * @param lengthValue The value to be assingned on the result.
     * @param totalLength The length of the padded string result.
     * @param padChar The character value to use as filling.
     * @returns The padded string.
     */
    static headerLengthPadder(lengthValue, totalLength, padChar) {
        const result = Array(totalLength + 1).join(padChar);
        const lengthString = lengthValue.toString();
        return (result + lengthString).slice(lengthString.length);
    }
}
exports.HeaderSerializer = HeaderSerializer;
HeaderSerializer.Delimiter = '.';
HeaderSerializer.Terminator = '\n';
HeaderSerializer.End = '1';
HeaderSerializer.NotEnd = '0';
HeaderSerializer.TypeOffset = 0;
HeaderSerializer.TypeDelimiterOffset = 1;
HeaderSerializer.LengthOffset = 2;
HeaderSerializer.LengthLength = 6;
HeaderSerializer.LengthDelimeterOffset = 8;
HeaderSerializer.IdOffset = 9;
HeaderSerializer.IdLength = 36;
HeaderSerializer.IdDelimeterOffset = 45;
HeaderSerializer.EndOffset = 46;
HeaderSerializer.TerminatorOffset = 47;
HeaderSerializer.Encoding = 'utf8';
//# sourceMappingURL=headerSerializer.js.map
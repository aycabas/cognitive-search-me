"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadReceiver = void 0;
const payloadTypes_1 = require("../payloads/payloadTypes");
const headerSerializer_1 = require("../payloads/headerSerializer");
const payloadConstants_1 = require("../payloads/payloadConstants");
const transportDisconnectedEvent_1 = require("./transportDisconnectedEvent");
/**
 * Payload receiver for streaming.
 */
class PayloadReceiver {
    /**
     * Get current connected state
     *
     * @returns true if connected to a transport sender.
     */
    get isConnected() {
        return this._receiver != null;
    }
    /**
     * Connects to a transport receiver
     *
     * @param receiver The [ITransportReceiver](xref:botframework-streaming.ITransportReceiver) object to pull incoming data from.
     * @returns a promise that resolves when the receiver is complete
     */
    connect(receiver) {
        this._receiver = receiver;
        return this.receivePackets();
    }
    /**
     * Allows subscribing to this receiver in order to be notified when new data comes in.
     *
     * @param getStream Callback when a new stream has been received.
     * @param receiveAction Callback when a new message has been received.
     */
    subscribe(getStream, receiveAction) {
        this._getStream = getStream;
        this._receiveAction = receiveAction;
    }
    /**
     * Force this receiver to disconnect.
     *
     * @param event Event arguments to include when broadcasting disconnection event.
     */
    disconnect(event = transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty) {
        var _a, _b;
        if (!this.isConnected) {
            return;
        }
        try {
            this._receiver.close();
            (_a = this.disconnected) === null || _a === void 0 ? void 0 : _a.call(this, this, event);
        }
        catch (err) {
            (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this, this, new transportDisconnectedEvent_1.TransportDisconnectedEvent(err.message));
        }
        finally {
            this._receiver = null;
        }
    }
    receivePackets() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.isConnected) {
                try {
                    let readSoFar = 0;
                    while (readSoFar < payloadConstants_1.PayloadConstants.MaxHeaderLength) {
                        this._receiveHeaderBuffer = yield this._receiver.receive(payloadConstants_1.PayloadConstants.MaxHeaderLength - readSoFar);
                        if (this._receiveHeaderBuffer) {
                            readSoFar += this._receiveHeaderBuffer.length;
                        }
                    }
                    const header = headerSerializer_1.HeaderSerializer.deserialize(this._receiveHeaderBuffer);
                    const isStream = header.payloadType === payloadTypes_1.PayloadTypes.stream;
                    if (header.payloadLength > 0) {
                        let bytesActuallyRead = 0;
                        const contentStream = this._getStream(header);
                        while (bytesActuallyRead < header.payloadLength &&
                            bytesActuallyRead < payloadConstants_1.PayloadConstants.MaxPayloadLength) {
                            const count = Math.min(header.payloadLength - bytesActuallyRead, payloadConstants_1.PayloadConstants.MaxPayloadLength);
                            this._receivePayloadBuffer = yield this._receiver.receive(count);
                            bytesActuallyRead += this._receivePayloadBuffer.byteLength;
                            contentStream.write(this._receivePayloadBuffer);
                            // If this is a stream we want to keep handing it up as it comes in
                            if (isStream) {
                                this._receiveAction(header, contentStream, bytesActuallyRead);
                            }
                        }
                        if (!isStream) {
                            this._receiveAction(header, contentStream, bytesActuallyRead);
                        }
                    }
                }
                catch (err) {
                    this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(err.message));
                }
            }
        });
    }
}
exports.PayloadReceiver = PayloadReceiver;
//# sourceMappingURL=payloadReceiver.js.map